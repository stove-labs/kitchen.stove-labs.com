(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{107:function(t,e,n){"use strict";n.r(e),n.d(e,"frontMatter",(function(){return c})),n.d(e,"metadata",(function(){return s})),n.d(e,"rightToc",(function(){return m})),n.d(e,"default",(function(){return l}));var a=n(2),o=n(6),r=(n(0),n(163)),i=n(174),c={id:"entrypoints",title:"Entrypoints"},s={id:"knowledge/smart_contract/entrypoints",isDocsHomePage:!1,title:"Entrypoints",description:"In Tezos there are two different types of accounts: *implicit* and **originated**. The latter is an account with Michelson **code attached** to it and is basically known as smart contract. It can be seen as a *collection of functions* that share and manipulate the same storage. Different to implicit accounts, originated accounts can receive more than just \ua729 in a transaction, namely parameters that are consumed when executing the code. Those parameters always first arrive at the main function of the code.",source:"@site/docs/knowledge/smart_contract/entrypoints.mdx",permalink:"/docs/knowledge/smart_contract/entrypoints",editUrl:"https://github.com/stove-labs/learn.stove-labs.com/edit/master/website/docs/knowledge/smart_contract/entrypoints.mdx",sidebar:"wiki",previous:{title:"Overview",permalink:"/docs/knowledge/smart_contract/smart-contract"},next:{title:"Michelson",permalink:"/docs/knowledge/smart_contract/michelson"}},m=[{value:"Example from the workshop",id:"example-from-the-workshop",children:[]}],h={rightToc:m};function l(t){var e=t.components,n=Object(o.a)(t,["components"]);return Object(r.b)("wrapper",Object(a.a)({},h,n,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"In Tezos there are two different types of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"../tezos_protocol/account"}),"accounts"),": ",Object(r.b)("em",{parentName:"p"},"implicit")," and ",Object(r.b)("strong",{parentName:"p"},"originated"),". The latter is an account with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"michelson"}),"Michelson")," ",Object(r.b)("strong",{parentName:"p"},"code attached")," to it and is basically known as ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"smart-contract"}),"smart contract"),". It can be seen as a ",Object(r.b)("em",{parentName:"p"},"collection of functions")," that share and manipulate the same storage. Different to implicit accounts, originated accounts can receive more than just \ua729 in a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"../tezos_protocol/operations/transaction"}),"transaction"),", namely ",Object(r.b)("strong",{parentName:"p"},"parameters")," that are consumed when ",Object(r.b)("strong",{parentName:"p"},"executing the code"),". Those parameters always first arrive at the main function of the code."),Object(r.b)("p",null,'The challenge is how to address specific functions from the "outside", while parameters are always passed to the main function? That\'s why we have so called\n',Object(r.b)("strong",{parentName:"p"},"entrypoints")," that work like the following: variants of ",Object(r.b)("strong",{parentName:"p"},"parameters")," get matched and ",Object(r.b)("strong",{parentName:"p"},"routed")," to the functions we want to address. In this way, entrypoints make functions explicitly callable from the outside of the smart contract."),Object(r.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"Remember")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Entrypoints make functions explicitly callable from the outside of a smart contract."))),Object(r.b)("h2",{id:"example-from-the-workshop"},"Example from the workshop"),Object(r.b)("p",null,"In the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"../../learn/workshops/notarization/overview"}),"notarization workshop")," the smart contract has two functions exposed with the help of entrypoints:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"NotarizeDocument(",Object(r.b)("strong",{parentName:"li"},"notarizeParameter"),"): It takes a new document hash to notarize and a list of signees."),Object(r.b)("li",{parentName:"ol"},"SignDocument(",Object(r.b)("strong",{parentName:"li"},"signParameter"),"): This signs an existing document for a given document hash.")),Object(r.b)("p",null,"The chart below shows how both ",Object(r.b)("strong",{parentName:"p"},"variants of the parameters")," are ",Object(r.b)("strong",{parentName:"p"},"matched")," in the main function of the smart contract. The variants are ",Object(r.b)("em",{parentName:"p"},"notarizeParameter")," with ",Object(r.b)("em",{parentName:"p"},"(documentHash, signees)")," and for ",Object(r.b)("em",{parentName:"p"},"signParameter")," with ",Object(r.b)("em",{parentName:"p"},"documentHash"),". Depending on which parameter is passed in the transaction, one of the two functions ",Object(r.b)("em",{parentName:"p"},"notarizeDocument")," and ",Object(r.b)("em",{parentName:"p"},"signDocument")," is called. As you can see, the exposed functions are calling other functions that are within the smart contract, which are not exposed to the outside."),Object(r.b)(i.a,{chart:'\ngraph TD\n  transaction["Transaction with parameters targets main function"]\n  transaction--\x3eentrypoints{"Main entrypoint <br> matches varying <br> parameters <br>to function"}\n  entrypoints--\x3e|"notarizeParameter: (documentHash, signees)"|NotarizeDocument\n  entrypoints--\x3e|signParameter: documentHash|SignDocument\n  SignDocument-.->signDocument\n  NotarizeDocument-.->notarizeDocument\n  subgraph smart contract\n    notarizeDocument["notarizeDocument(documentHash, signees)"]\n    getEmpty["getEmptydocumentSignatures()"]\n    addDocument["addDocumentHashWithSigneesToNotary()"]\n    notarizeDocument--\x3e|calls internally|addDocument\n    addDocument--\x3e|calls internally|getEmpty\n    addSign["addSignatureToDocumentSignaturesOrFail()"]\n    signDocument["signDocument(documentHash)"]\n    signDocument --\x3e|calls internally|addSign\n  end\n',mdxType:"Mermaid"}),Object(r.b)("p",null,"We can also look at the code that does this matching. It is written in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.ligolang.org"}),"Ligo")," in the ",Object(r.b)("em",{parentName:"p"},"ReasonLIGO")," flavor. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="workshop-notarization/smart-contracts/contracts/main/notary.religo and contracts/partials/notary/action/action.religo"',title:'"workshop-notarization/smart-contracts/contracts/main/notary.religo',and:!0,'contracts/partials/notary/action/action.religo"':!0}),"/**\n * Unique set of addresses which will be able\n * to co-sign the document.\n */\ntype signees = set(signee);\n/**\n * Parameter for the `NotarizeDocument` entrypoint,\n * accepting a hash to be notarized along with a set of signees.\n */\n  // highlight-start\ntype notarizeParameter = {\n    documentHash: documentHash,\n    signees: signees\n};\n  // highlight-end\n\n/**\n * Parameter for the `SignDocument` entrypoint,\n * accepting a single document hash to be signed.\n */\n  // highlight-start\ntype signParameter = documentHash;\n  // highlight-end\n\ntype action = \n    /**\n     * Propose a new document hash to notarize\n     */\n    | NotarizeDocument(notarizeParameter)\n    /**\n     * Sign an existing document with a new signature\n     */\n    | SignDocument(signParameter);\n/**\n * Main function representing the Notary contract\n */\nlet main = ((action, storage): (action, storage)) : entrypointReturn => \n  \n  /**\n   * Entrypoint routing\n   */\n  // highlight-start\n  switch (action) {\n    | NotarizeDocument(notarizeParameter) => notarizeDocument(notarizeParameter, storage);\n    | SignDocument(signParameter) => signDocument(signParameter, storage);\n  }\n  // highlight-end\n")))}l.isMDXComponent=!0},174:function(t,e,n){"use strict";var a=n(0),o=n.n(a),r=n(190),i=n.n(r);i.a.initialize({startOnLoad:!0,themeCSS:"\n\t\t\t.node rect { fill: #f7f8fe; stroke: #000000 } \n\t\t\t.node polygon { fill: #f7f8fe; stroke: #000000 } \n\t\t\t.node path { fill: #f7f8fe; stroke: #000000 } \n\t\t\t.nodeWarning > rect{fill:#FFD03B; stroke:#000000;}\n\t\t\t.nodeDanger > rect{fill: #F86D70; stroke:#000000;} \n\t\t\t.nodeTezos > .label{color: #ffffff} \n\t\t\t.nodeTezos > rect {fill: #536DFE}\n\t\t"});e.a=({chart:t})=>(Object(a.useEffect)(()=>{i.a.contentLoaded()},[]),o.a.createElement("div",{className:"mermaid"},t))},191:function(t,e){},192:function(t,e){},193:function(t,e){},194:function(t,e){},195:function(t,e){},196:function(t,e){},197:function(t,e){},198:function(t,e){},200:function(t,e){},201:function(t,e){},202:function(t,e){},203:function(t,e){},204:function(t,e){},207:function(t,e,n){var a={"./locale":173,"./locale.js":173};function o(t){var e=r(t);return n(e)}function r(t){if(!n.o(a,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return a[t]}o.keys=function(){return Object.keys(a)},o.resolve=r,t.exports=o,o.id=207}}]);